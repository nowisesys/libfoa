Makefile:		    decode.c encode.c libfoa-utils.h
Makefile.am:		    decode.c encode.c libfoa-utils.h
Makefile.in:		    decode.c encode.c libfoa-utils.h
decode.c: * Decode the entity in foa->buff and update foa->entity. 
decode.c:	foa->entity.line = foa->line;
decode.c:	foa->entity.name = NULL;
decode.c:	if(*foa->buff == '\n') {
decode.c:		foa->entity.data = "unexpected empty line";
decode.c:		foa->entity.type = FOA_TYPE_ERROR_MESSAGE;
decode.c:	if((pp = strchr(foa->buff, FOA_TYPE_NAME_DATA))) {
decode.c:		if(foa->hashes != 1) {
decode.c:			foa->entity.data = "named data is not allowed";
decode.c:			foa->entity.type = FOA_TYPE_ERROR_MESSAGE;
decode.c:		foa->entity.name = foa->buff;
decode.c:		foa->entity.data = eat_white(pp);
decode.c:		if(!strchr(FOA_TYPE_SPEC_CHARS, *foa->entity.data))
decode.c:			foa->entity.type = FOA_TYPE_DATA_ENTITY;
decode.c:			foa->entity.type = *foa->entity.data;
decode.c:		foa->entity.data = foa->buff;
decode.c:		foa->entity.type = FOA_TYPE_DATA_ENTITY;
decode.c:	if(strchr(FOA_TYPE_SPEC_CHARS, *foa->entity.data)) {
decode.c:		if(strlen(foa->entity.data) != 1) {
decode.c:			if(strchr(FOA_TYPE_SPEC_CHARS, foa->entity.data[1])) {
decode.c:				foa->entity.data = "multiple special chars without newline separator";
decode.c:				foa->entity.type = FOA_TYPE_ERROR_MESSAGE;
decode.c:			} else if(foa->entity.data[1] != '\n') {
decode.c:				foa->entity.data = "garbage character after special char";
decode.c:				foa->entity.type = FOA_TYPE_ERROR_MESSAGE;
decode.c:				foa->entity.data[1] = '\0';
decode.c:			foa->entity.data = "special chars without trailing newline";
decode.c:			foa->entity.type = FOA_TYPE_ERROR_MESSAGE;
decode.c:		foa->entity.type = *foa->buff;
decode.c:	if((pp = strchr(foa->entity.data, '\n'))) *pp = '\0';
encode.c:		if(!foa->hashes) {
encode.c:			logerr(&foa->errmsg, 0, "named data is not allowed");
encode.c:			logerr(&foa->errmsg, 0, "missing data argument");
encode.c:				if(foa->escape && 
encode.c:				} else if(foa->hashes && 
encode.c:					if(foa->hashes) {
encode.c:		logerr(&foa->errmsg, 0, "invalid encode type: %d", type);
encode.c:		foa->buff[0] = '\0';
encode.c:		foa->used = 0;
encode.c:	puts = foa->used + need;
encode.c:	if(need + foa->used > foa->max) {
encode.c:		logerr(&foa->errmsg, 0, "maximum buffer size reached");
encode.c:	if(need + foa->used > foa->size) {
encode.c:		if(need < foa->step) 
encode.c:			foa->size += foa->step;
encode.c:			foa->size += need + 1;
encode.c:		foa->buff = realloc(foa->buff, foa->size);
encode.c:		foa->used += sprintf(foa->buff + foa->used,
encode.c:		foa->used += sprintf(foa->buff + foa->used, "%c", type);
encode.c:		if(!doesc || (!foa->escape && !foa->hashes)) {
encode.c:			foa->used += sprintf(foa->buff + foa->used, "%s", data);
encode.c:				if(foa->escape && 
encode.c:					foa->used += sprintf(foa->buff + foa->used, 
encode.c:				} else if(foa->hashes && 
encode.c:					foa->used += sprintf(foa->buff + foa->used, 
encode.c:					foa->used += sprintf(foa->buff + foa->used,
encode.c:	foa->used += sprintf(foa->buff + foa->used, "\n");
encode.c:	if(puts != foa->used) {
encode.c:		logerr(&foa->errmsg, 0, "failed write %lu bytes", need);
encode.c:	if(foa->file) 
encode.c:		fprintf(foa->file, "%s", foa->buff);
encode.c:	return foa->buff;
internal.h: * Decode the entity in foa->buff and update foa->entity.
libfoa.c:	foa->size = FOA_MEMORY_ALLOC_INIT;
libfoa.c:	foa->step = FOA_MEMORY_ALLOC_STEP;
libfoa.c:	foa->max  = FOA_MEMORY_ALLOC_MAX;
libfoa.c:	foa->buff = malloc(foa->size);
libfoa.c:	if(!foa->buff) {
libfoa.c:		write_errlog(&foa->errmsg, errno, "failed alloc memory");
libfoa.c:	foa->escape = FOA_ENABLE_ESCAPE;
libfoa.c:	foa->hashes = FOA_ENABLE_HASHES;
libfoa.c:	free(foa->buff);
libfoa.c:	free(foa->errmsg);
libfoa.c:	foa->func = func;
libfoa.c:	foa->arg  = arg;
libfoa.c:	foa->line = 1;
libfoa.c:	foa->used = 0;
libfoa.c:	foa->curr = foa->next = NULL;
libfoa.c:	foa->file = file;
libfoa.c:	foa->line = 1;
libfoa.c:	foa->used = 0;
libfoa.c:	foa->file = NULL;
libfoa.c:	foa->curr = input;
libfoa.c:	foa->next = strchr(foa->curr, '\n');	
libfoa.c:		foa->escape = enable == 0 ? 0 : 1;
libfoa.c:		foa->hashes = enable == 0 ? 0 : 1;
libfoa.c:		*enable = foa->escape;
libfoa.c:		*enable = foa->hashes;
libfoa.c:	if(!foa->func) {
libfoa.c:		logerr(&foa->errmsg, 0, "no callback function defined");
libfoa.c:	if(!foa->curr && !foa->file) {
libfoa.c:		logerr(&foa->errmsg, 0, "no input stream or memory buffer is set");
libfoa.c:	if(foa->file) {
libfoa.c:		while(!feof(foa->file)) {
libfoa.c:				return feof(foa->file) ? 0 : -1;
libfoa.c:			if(!foa->func(&foa->entity, foa->arg)) {
libfoa.c:		while(foa->curr) {
libfoa.c:			if(!foa->func(&foa->entity, foa->arg)) {
libfoa.c:	if(foa->file) {
libfoa.c:		if(feof(foa->file)) {
libfoa.c:	} else if(foa->curr) {
libfoa.c:		if(!foa->curr && foa->line != 1) {
libfoa.c:		logerr(&foa->errmsg, 0, "input stream or memory is unset");
libfoa.c:	return &foa->entity;
libfoa.c:	free(foa->errmsg);
libfoa.c:	foa->errmsg = NULL;
libfoa.c:	return foa->buff;
libfoa.c~:	foa->size = FOA_MEMORY_ALLOC_INIT;
libfoa.c~:	foa->step = FOA_MEMORY_ALLOC_STEP;
libfoa.c~:	foa->max  = FOA_MEMORY_ALLOC_MAX;
libfoa.c~:	foa->buff = malloc(foa->size);
libfoa.c~:	if(!foa->buff) {
libfoa.c~:		write_errlog(&foa->errmsg, errno, "failed alloc memory");
libfoa.c~:	foa->escape = FOA_ENABLE_ESCAPE;
libfoa.c~:	foa->hashes = FOA_ENABLE_HASHES;
libfoa.c~:	free(foa->buff);
libfoa.c~:	free(foa->errmsg);
libfoa.c~:	foa->func = func;
libfoa.c~:	foa->arg  = arg;
libfoa.c~:	foa->line = 1;
libfoa.c~:	foa->used = 0;
libfoa.c~:	foa->curr = foa->next = NULL;
libfoa.c~:	foa->file = file;
libfoa.c~:	foa->line = 1;
libfoa.c~:	foa->used = 0;
libfoa.c~:	foa->file = NULL;
libfoa.c~:	foa->curr = input;
libfoa.c~:	foa->next = strchr(foa->curr, '\n');	
libfoa.c~:		foa->escape = enable == 0 ? 0 : 1;
libfoa.c~:		foa->hashes = enable == 0 ? 0 : 1;
libfoa.c~:		*enable = foa->escape;
libfoa.c~:		*enable = foa->hashes;
libfoa.c~:	if(!foa->func) {
libfoa.c~:		logerr(&foa->errmsg, 0, "no callback function defined");
libfoa.c~:	if(!foa->curr && !foa->file) {
libfoa.c~:		logerr(&foa->errmsg, 0, "no input stream or memory buffer is set");
libfoa.c~:	if(foa->file) {
libfoa.c~:		while(!feof(foa->file)) {
libfoa.c~:				return feof(foa->file) ? 0 : -1;
libfoa.c~:			if(!foa->func(&foa->entity, foa->arg)) {
libfoa.c~:		while(foa->curr) {
libfoa.c~:			if(!foa->func(&foa->entity, foa->arg)) {
libfoa.c~:	if(foa->file) {
libfoa.c~:		if(feof(foa->file)) {
libfoa.c~:	} else if(foa->curr) {
libfoa.c~:		if(!foa->curr && foa->line != 1) {
libfoa.c~:		logerr(&foa->errmsg, 0, "input stream or memory is unset");
libfoa.c~:	return &foa->entity;
libfoa.c~:	free(foa->errmsg);
libfoa.c~:	foa->errmsg = NULL;
libfoa.c~:	return foa->buff;
libfoa.h:	return foa->errmsg;
libfoa.h:	return foa->errmsg ? 1 : 0;
libfoa.h~:	return foa->errmsg;
libfoa.h~:	return foa->errmsg ? 1 : 0;
memory.c: * if end of buffer is found. Use foa->curr to detect if end of
memory.c:	if(!foa->curr || *foa->curr == '\0')
memory.c:	if(foa->next) 
memory.c:		if(*foa->next == '\n')
memory.c:			foa->next++;
memory.c:	if(foa->next)
memory.c:		need = foa->next - foa->curr;
memory.c:		need = strlen(foa->curr);
memory.c:	if(need > foa->size) {
memory.c:		if(need > foa->max) {
memory.c:			logerr(&foa->errmsg, 0, "maximum buffer size reached");
memory.c:		if(need < foa->step)
memory.c:			foa->size += foa->step;
memory.c:			foa->size = need + 1;
memory.c:		foa->buff = realloc(foa->buff, foa->size);
memory.c:		if(!foa->buff) {
memory.c:			logerr(&foa->errmsg, errno, "failed alloc memory");
memory.c:	memcpy(foa->buff, foa->curr, need);
memory.c:	foa->buff[need] = '\0';
memory.c:	if((foa->curr = foa->next)) 
memory.c:		foa->next = strchr(foa->curr + 1, '\n');
memory.c:	foa->line++;
stream.c:	for(put = foa->buff;; put += foa->step) {
stream.c:		res = fgets(put, foa->size - 1, foa->file);
stream.c:			if(!feof(foa->file))
stream.c:				logerr(&foa->errmsg, errno, "failed read stream");
stream.c:		if(foa->size + foa->step > foa->max) {
stream.c:			logerr(&foa->errmsg, 0, "maximum buffer size reached");
stream.c:		foa->size += foa->step;
stream.c:		foa->buff = realloc(foa->buff, foa->size);
stream.c:		if(!foa->buff) {
stream.c:			logerr(&foa->errmsg, errno, "failed alloc memory");
stream.c:			foa->size = 0;
stream.c:		printf("realloc: %lu bytes\n", foa->size);
stream.c:	foa->line++;
stream.c~:	for(put = foa->buff;; put += foa->step) {
stream.c~:		res = fgets(put, foa->size - 1, foa->file);
stream.c~:			if(!feof(foa->file)) {
stream.c~:				logerr(&foa->errmsg, errno, "failed read stream");
stream.c~:		if(foa->size + foa->step > foa->max) {
stream.c~:			logerr(&foa->errmsg, 0, "maximum buffer size reached");
stream.c~:		foa->size += foa->step;
stream.c~:		foa->buff = realloc(foa->buff, foa->size);
stream.c~:		if(!foa->buff) {
stream.c~:			logerr(&foa->errmsg, errno, "failed alloc memory");
stream.c~:			foa->size = 0;
stream.c~:		printf("realloc: %lu bytes\n", foa->size);
stream.c~:	foa->line++;
